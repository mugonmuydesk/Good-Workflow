// PROTECTED TEST: Do not edit this file after initial creation
// This file tests the parser implementation for extracting function information from C++ source files.

#include "../include/parser.h"
#include "../include/json_exporter.h"
#include <iostream>
#include <cassert>
#include <filesystem>
#include <fstream>
#include <algorithm>

namespace fs = std::filesystem;

// Helper function to create a temporary test file
std::string createTestFile(const std::string& filename, const std::string& content) {
    std::string path = "/tmp/" + filename;
    std::ofstream file(path);
    file << content;
    file.close();
    return path;
}

// Test CppParser constructor
void test_CppParser_constructor() {
    std::cout << "Testing CppParser constructor... ";
    codemap::CppParser parser;
    // Constructor should not throw
    std::cout << "PASSED" << std::endl;
}

// Test getSupportedExtensions
void test_CppParser_getSupportedExtensions() {
    std::cout << "Testing CppParser::getSupportedExtensions... ";
    codemap::CppParser parser;
    auto extensions = parser.getSupportedExtensions();
    
    assert(extensions.size() > 0);
    assert(std::find(extensions.begin(), extensions.end(), ".cpp") != extensions.end());
    assert(std::find(extensions.begin(), extensions.end(), ".h") != extensions.end());
    assert(std::find(extensions.begin(), extensions.end(), ".hpp") != extensions.end());
    
    std::cout << "PASSED" << std::endl;
}

// Test parseFile with empty file
void test_CppParser_parseFile_empty() {
    std::cout << "Testing CppParser::parseFile with empty file... ";
    codemap::CppParser parser;
    
    std::string testFile = createTestFile("empty.cpp", "");
    auto graph = parser.parseFile(testFile);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() == 0);
    assert(graph->edges.size() == 0);
    assert(graph->isValid());
    
    fs::remove(testFile);
    std::cout << "PASSED" << std::endl;
}

// Test parseFile with single function
void test_CppParser_parseFile_single_function() {
    std::cout << "Testing CppParser::parseFile with single function... ";
    codemap::CppParser parser;
    
    std::string code = R"(
#include <iostream>

void hello() {
    std::cout << "Hello, World!" << std::endl;
}
)";
    
    std::string testFile = createTestFile("single_func.cpp", code);
    auto graph = parser.parseFile(testFile);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() >= 1);  // Should find at least 'hello' function
    
    // Find the hello function
    int helloIdx = graph->findNodeIndex("hello");
    assert(helloIdx >= 0);
    assert(graph->nodes[helloIdx].name == "hello");
    assert(!graph->nodes[helloIdx].isStub);
    assert(!graph->nodes[helloIdx].isMissing);
    
    assert(graph->isValid());
    
    fs::remove(testFile);
    std::cout << "PASSED" << std::endl;
}

// Test parseFile with function calls
void test_CppParser_parseFile_with_calls() {
    std::cout << "Testing CppParser::parseFile with function calls... ";
    codemap::CppParser parser;
    
    std::string code = R"(
void helper() {
    // Helper function
}

void caller() {
    helper();
    helper();  // Call twice
}

int main() {
    caller();
    helper();
    return 0;
}
)";
    
    std::string testFile = createTestFile("with_calls.cpp", code);
    auto graph = parser.parseFile(testFile);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() >= 3);  // helper, caller, main
    assert(graph->edges.size() >= 3);  // main->caller, main->helper, caller->helper
    
    int mainIdx = graph->findNodeIndex("main");
    int callerIdx = graph->findNodeIndex("caller");
    int helperIdx = graph->findNodeIndex("helper");
    
    assert(mainIdx >= 0);
    assert(callerIdx >= 0);
    assert(helperIdx >= 0);
    
    // Verify edges exist (main calls caller and helper, caller calls helper)
    bool mainCallsCaller = false;
    bool mainCallsHelper = false;
    bool callerCallsHelper = false;
    
    for (const auto& edge : graph->edges) {
        if (edge.first == mainIdx && edge.second == callerIdx) mainCallsCaller = true;
        if (edge.first == mainIdx && edge.second == helperIdx) mainCallsHelper = true;
        if (edge.first == callerIdx && edge.second == helperIdx) callerCallsHelper = true;
    }
    
    assert(mainCallsCaller);
    assert(mainCallsHelper);
    assert(callerCallsHelper);
    assert(graph->isValid());
    
    fs::remove(testFile);
    std::cout << "PASSED" << std::endl;
}

// Test parseFile with missing function
void test_CppParser_parseFile_missing_function() {
    std::cout << "Testing CppParser::parseFile with missing function... ";
    codemap::CppParser parser;
    
    std::string code = R"(
void caller() {
    undefined_function();  // This function doesn't exist
}
)";
    
    std::string testFile = createTestFile("missing_func.cpp", code);
    auto graph = parser.parseFile(testFile);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() >= 1);  // Should find caller and possibly undefined_function
    
    int callerIdx = graph->findNodeIndex("caller");
    assert(callerIdx >= 0);
    
    // Check if undefined_function was detected
    int undefinedIdx = graph->findNodeIndex("undefined_function");
    if (undefinedIdx >= 0) {
        // If found, it should be marked as missing or external
        assert(graph->nodes[undefinedIdx].isMissing || graph->nodes[undefinedIdx].isExternal);
    }
    
    assert(graph->isValid());
    
    fs::remove(testFile);
    std::cout << "PASSED" << std::endl;
}

// Test parseFile with stub function
void test_CppParser_parseFile_stub_function() {
    std::cout << "Testing CppParser::parseFile with stub function... ";
    codemap::CppParser parser;
    
    std::string code = R"(
void implemented() {
    int x = 42;
    return;
}

void stub_todo() {
    // TODO: implement this
}

void stub_throw() {
    throw std::runtime_error("Not implemented");
}
)";
    
    std::string testFile = createTestFile("stub_func.cpp", code);
    auto graph = parser.parseFile(testFile);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() >= 2);  // At least implemented and one stub
    
    int implementedIdx = graph->findNodeIndex("implemented");
    if (implementedIdx >= 0) {
        assert(!graph->nodes[implementedIdx].isStub);
    }
    
    // Note: Stub detection might need refinement in the actual implementation
    // For now, just verify the parse completes successfully
    assert(graph->isValid());
    
    fs::remove(testFile);
    std::cout << "PASSED" << std::endl;
}

// Test parseFile with non-existent file
void test_CppParser_parseFile_nonexistent() {
    std::cout << "Testing CppParser::parseFile with non-existent file... ";
    codemap::CppParser parser;
    
    auto graph = parser.parseFile("/tmp/this_file_does_not_exist_12345.cpp");
    
    assert(graph != nullptr);  // Should return empty graph, not null
    assert(graph->nodes.size() == 0);
    assert(graph->edges.size() == 0);
    assert(graph->isValid());
    
    std::cout << "PASSED" << std::endl;
}

// Test parseProject with empty directory
void test_CppParser_parseProject_empty_dir() {
    std::cout << "Testing CppParser::parseProject with empty directory... ";
    codemap::CppParser parser;
    
    // Create temporary directory
    std::string tempDir = "/tmp/codemap_test_" + std::to_string(std::rand());
    fs::create_directory(tempDir);
    
    auto graph = parser.parseProject(tempDir);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() == 0);
    assert(graph->edges.size() == 0);
    assert(graph->isValid());
    
    fs::remove(tempDir);
    std::cout << "PASSED" << std::endl;
}

// Test parseProject with multiple files
void test_CppParser_parseProject_multiple_files() {
    std::cout << "Testing CppParser::parseProject with multiple files... ";
    codemap::CppParser parser;
    
    // Create temporary directory with files
    std::string tempDir = "/tmp/codemap_test_" + std::to_string(std::rand());
    fs::create_directory(tempDir);
    
    // Create file1.cpp
    std::ofstream file1(tempDir + "/file1.cpp");
    file1 << R"(
void func1() {
    // Function in file1
}

void func2() {
    func1();
}
)";
    file1.close();
    
    // Create file2.cpp
    std::ofstream file2(tempDir + "/file2.cpp");
    file2 << R"(
void func3() {
    // Function in file2
}

void func4() {
    func3();
}
)";
    file2.close();
    
    auto graph = parser.parseProject(tempDir);
    
    assert(graph != nullptr);
    assert(graph->nodes.size() >= 4);  // func1, func2, func3, func4
    assert(graph->edges.size() >= 2);  // func2->func1, func4->func3
    
    assert(graph->findNodeIndex("func1") >= 0);
    assert(graph->findNodeIndex("func2") >= 0);
    assert(graph->findNodeIndex("func3") >= 0);
    assert(graph->findNodeIndex("func4") >= 0);
    
    assert(graph->isValid());
    
    // Clean up
    fs::remove_all(tempDir);
    std::cout << "PASSED" << std::endl;
}

// Test parseProject with non-existent directory
void test_CppParser_parseProject_nonexistent() {
    std::cout << "Testing CppParser::parseProject with non-existent directory... ";
    codemap::CppParser parser;
    
    auto graph = parser.parseProject("/tmp/nonexistent_dir_12345");
    
    assert(graph != nullptr);  // Should return empty graph
    assert(graph->nodes.size() == 0);
    assert(graph->edges.size() == 0);
    assert(graph->isValid());
    
    std::cout << "PASSED" << std::endl;
}

// Test integration with JsonExporter
void test_CppParser_json_export_integration() {
    std::cout << "Testing CppParser integration with JsonExporter... ";
    codemap::CppParser parser;
    codemap::JsonExporter exporter;
    
    std::string code = R"(
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int result = fibonacci(5);
    return 0;
}
)";
    
    std::string testFile = createTestFile("fib.cpp", code);
    auto graph = parser.parseFile(testFile);
    
    assert(graph != nullptr);
    
    // Export to JSON
    std::string json = exporter.graphToJSON(*graph);
    assert(!json.empty());
    assert(exporter.isValidGraphJSON(json));
    
    // Verify JSON contains expected functions
    assert(json.find("fibonacci") != std::string::npos);
    assert(json.find("main") != std::string::npos);
    
    fs::remove(testFile);
    std::cout << "PASSED" << std::endl;
}

// Main test runner
int main() {
    std::cout << "Running Comprehensive Parser Tests" << std::endl;
    std::cout << "==========================================\n" << std::endl;
    
    std::cout << "--- CppParser Basic Tests ---" << std::endl;
    test_CppParser_constructor();
    test_CppParser_getSupportedExtensions();
    
    std::cout << "\n--- CppParser::parseFile Tests ---" << std::endl;
    test_CppParser_parseFile_empty();
    test_CppParser_parseFile_single_function();
    test_CppParser_parseFile_with_calls();
    test_CppParser_parseFile_missing_function();
    test_CppParser_parseFile_stub_function();
    test_CppParser_parseFile_nonexistent();
    
    std::cout << "\n--- CppParser::parseProject Tests ---" << std::endl;
    test_CppParser_parseProject_empty_dir();
    test_CppParser_parseProject_multiple_files();
    test_CppParser_parseProject_nonexistent();
    
    std::cout << "\n--- Integration Tests ---" << std::endl;
    test_CppParser_json_export_integration();
    
    std::cout << "\n==========================================" << std::endl;
    std::cout << "All Parser tests PASSED!" << std::endl;
    std::cout << "Total test functions: 12" << std::endl;
    
    return 0;
}